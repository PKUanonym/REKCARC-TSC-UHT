/*
 * File:     prog3.4b_mpi_tree_sum.c
 *
 * Purpose:  Use butterfly-structured communication to find the global sum
 *           of a random collection of ints.  This version is correct when
 *           comm_sz is not a power of 2.
 *
 * Compile:  mpicc -g -Wall -o prog3.4b_mpi_tree_sum prog3.4b_mpi_tree_sum.c
 * Run:      mpiexec -n <comm_sz> ./prog3.4b_mpi_tree_sum
 *
 * Input:    None
 * Output:   Random values generated by processes, and global sum computed
 *           by each process.
 *
 * Algorithm:     
 * Suppose q is the largest power of 2 <= comm_sz.  Then if process r
 * has rank >= q, it sends its value process r-q, and process r-q adds
 * the received value to its value.  Now processes 0, 1, . . . , q-1 
 * carry out a butterfly structured reduction.  When they're done with
 * the butterfly, process r-q sends its sum to process r.
 *
 * Note:
 * See http://www.serc.iisc.ernet.in/~vss/courses/PPP/
 * CollectiveCommunicationImplementations.ppt for a discussion of 
 * reduction algorithms
 *
 * IPP:      Programming Assignment Chapter 3.4, first part
 */


#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>

int Global_sum(int my_int, int my_rank, int comm_sz, MPI_Comm comm); 
int Floor_log(int comm_sz);

const int MAX_CONTRIB = 20;

int main(void) {
   int i, sum, my_int;
   int my_rank, comm_sz;
   MPI_Comm comm;
   int* all_ints = NULL;
   
   MPI_Init(NULL, NULL);
   comm = MPI_COMM_WORLD;
   MPI_Comm_size(comm, &comm_sz);
   MPI_Comm_rank(comm, &my_rank);

   srandom(my_rank + 1);
   my_int = random() % MAX_CONTRIB;
   
   sum = Global_sum(my_int, my_rank, comm_sz, comm);
   
   if ( my_rank == 0) {
      all_ints = malloc(comm_sz*sizeof(int));
      MPI_Gather(&my_int, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
      printf("Ints being summed:\n   ");
      for (i = 0; i < comm_sz; i++)
         printf("%d ", all_ints[i]);
      printf("\n");
      MPI_Gather(&sum, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
      printf("Sums on the processes:\n   ");
      for (i = 0; i < comm_sz; i++)
         printf("%d ", all_ints[i]);
      printf("\n");
      free(all_ints);
   } else {
      MPI_Gather(&my_int, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
      MPI_Gather(&sum, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
   }
   
   MPI_Finalize();
   return 0;
}  /* main */

/*-------------------------------------------------------------------
 * Function:   Global_sum
 * Purpose:    Implement a global sum using butterfly-structured 
 *             communication
 * Notes:       
 * 1.  The return value is valid on all the processes
 */
int Global_sum(
      int my_int    /* in */,
      int my_rank   /* in */,
      int comm_sz   /* in */,
      MPI_Comm comm /* in */) {
   
   int partner, recvtemp;
   int my_sum = my_int;
   unsigned bitmask = 1;
   int floor_log_p = Floor_log(comm_sz);

   /* Get values from processes with rank >= floor_log_p */
   if (my_rank >= floor_log_p) {
      partner = my_rank - floor_log_p;
      MPI_Send(&my_sum, 1, MPI_INT, partner, 0, comm);
   } else {
      partner = my_rank + floor_log_p;
      if (partner < comm_sz) {
         MPI_Recv(&recvtemp, 1, MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
         my_sum += recvtemp;
      }
   }
   
   /* Butterfly with processes with rank < floor_log_p */
   if (my_rank < floor_log_p)
      while (bitmask < floor_log_p) {
         partner = my_rank ^ bitmask;
         MPI_Sendrecv(&my_sum, 1, MPI_INT, partner, 0, 
               &recvtemp, 1, MPI_INT, partner, 0, comm,
               MPI_STATUS_IGNORE);
         my_sum += recvtemp;
         bitmask <<= 1;
      }  /* while */

   /* Send result to processes with rank >= floor_log_p */
   if (my_rank >= floor_log_p) {
      partner = my_rank - floor_log_p;
      MPI_Recv(&my_sum, 1, MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
   } else {
      partner = my_rank + floor_log_p;
      if (partner < comm_sz)
         MPI_Send(&my_sum, 1, MPI_INT, partner, 0, comm);
   }

   return my_sum;
}  /* Global_sum */


/*-------------------------------------------------------------------*/
int Floor_log(int comm_sz) {
   int fl = 1;

   while (2*fl <= comm_sz)
      fl *= 2;

   return fl;
}  /* Floor_log */
