1. 基类中的`virtual Base& g2(){}`可以被派生类中的`Derive& g2(){}`重写覆盖；但非const函数不能被const函数重写覆盖。
2. 纯虚函数可以有函数体，但必须在类外定义。
```cpp
class A{
public:
    A(){}
    virtual void V() = 0;
};
void A::V(){
}
```

3. const T& 与 T& 不冲突,而 T 和 T& 可能引发冲突的原因：
    * 函数参数不同导致的函数重载
        - 非常量左值（如 int x）会优先匹配 T&，因为不需要添加 const 限定；而常量左值（如 const int x）只能匹配 const T&。
        - 右值（如 42）可以绑定到 const T&，但不能绑定到 T&。
        - 但对于T 和 T&, 当传入非常量左值时，编译器无法区分按值传递，还是直接传引用。
    * 类型转换函数的不同
        - 对于`int x = w`（涉及隐式类型转换），编译器分不清应该调用`operator int()`(直接返回值)还是`operator int&()`（返回引用，然后解引用后再拷贝）。因为*两个转换路径的优先级相同*
    * tips：尽量避免同时定义 T 和 T& 的重载或转换函数，或通过 ==explicit== 关键字限制隐式转换。